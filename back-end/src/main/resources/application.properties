spring.application.name=CorpoDeBombeiros
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
# --- AJUSTES EXTREMAMENTE AGRESSIVOS PARA AMBIENTES LIMITADOS ---

# 1. Reduza o Pool para um valor BEM BAIXO (máximo de 5 ou 7 conexões por Worker)
# Isso limita o impacto de cada worker no MySQL.
spring.datasource.hikari.maximum-pool-size=7 

# 2. Reduza o Timeout Ocioso para 30 segundos
# O pool fechará a conexão se ela ficar inativa por 30 segundos.
spring.datasource.hikari.idle-timeout=30000 

# 3. Mantenha o tempo de vida máximo para forçar a reconexão.
spring.datasource.hikari.max-lifetime=300000 

# 4. Mínimo de conexões ociosas (MANTENHA BEM BAIXO para não desperdiçar RAM)
spring.datasource.hikari.minimum-idle=1

# Tamanho máximo de CADA arquivo multipart (ex: anexo ou assinatura)
spring.servlet.multipart.max-file-size=50MB
# Tamanho máximo TOTAL da requisição (JSON + anexo + assinatura)
spring.servlet.multipart.max-request-size=101MB

# Diretório para uploads
app.upload.dir=uploads

# Variáveis de ambiente do Railway (escapadas para evitar filtering)
spring.datasource.url=\${DB_URL}
spring.datasource.username=\${DB_USERNAME}
spring.datasource.password=\${DB_PASSWORD}

cloudinary.cloud-name=\${CLOUD_NAME}
cloudinary.api-key=\${API_KEY}
cloudinary.api-secret=\${API_SECRET_KEY}

jwt.secret.key=\${JWT_SECRET_KEY}
